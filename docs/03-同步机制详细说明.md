\# åŒæ­¥æœºåˆ¶è¯¦ç»†è¯´æ˜



\*\*æ–‡æ¡£ç‰ˆæœ¬\*\*:  v1.0  

\*\*åˆ›å»ºæ—¥æœŸ\*\*: 2025-12-26  

\*\*ä½œè€…\*\*: SAiNTe3



---



\## ç›®å½•



\- \[1. æ¦‚è¿°](#1-æ¦‚è¿°)

\- \[2. Windows ç³»ç»Ÿè°ƒç”¨æ¸…å•](#2-windows-ç³»ç»Ÿè°ƒç”¨æ¸…å•)

\- \[3. åŒæ­¥åŸè¯­å®ç°](#3-åŒæ­¥åŸè¯­å®ç°)

\- \[4. åŒæ­¥åœºæ™¯åˆ†æ](#4-åŒæ­¥åœºæ™¯åˆ†æ)

\- \[5. æ­»é”é¿å…æœºåˆ¶](#5-æ­»é”é¿å…æœºåˆ¶)

\- \[6. æ€§èƒ½ä¼˜åŒ–](#6-æ€§èƒ½ä¼˜åŒ–)



---



\## 1. æ¦‚è¿°



\### 1.1 è®¾è®¡åŸåˆ™



æœ¬é¡¹ç›®éµå¾ªä»¥ä¸‹åŒæ­¥è®¾è®¡åŸåˆ™ï¼š



1\. \*\*æœ€å°é”ç²’åº¦\*\*: æ¯ä¸ªå‰å­ç‹¬ç«‹é”ï¼Œé¿å…å…¨å±€é”

2\. \*\*éé˜»å¡ä¼˜å…ˆ\*\*: ä¼˜å…ˆä½¿ç”¨ `try\_lock()` è€Œéé˜»å¡ `lock()`

3\. \*\*RAII ä¿è¯\*\*: ä½¿ç”¨ `WinLockGuard` è‡ªåŠ¨ç®¡ç†é”ç”Ÿå‘½å‘¨æœŸ

4\. \*\*æ— é¥¥é¥¿ä¿è¯\*\*: åŸºäºç­‰å¾…è®¡æ•°çš„ä¼˜å…ˆçº§è°ƒåº¦

5\. \*\*æ­»é”é¿å…\*\*:  Banker's Algorithm + è¶…æ—¶é‡è¯•



\### 1.2 æŠ€æœ¯é€‰å‹



| éœ€æ±‚ | POSIX | Windows é€‰æ‹© | ç†ç”± |

|------|-------|-------------|------|

| äº’æ–¥é” | `pthread\_mutex\_t` | `CRITICAL\_SECTION` | ç”¨æˆ·æ€å¿«é€Ÿè·¯å¾„ï¼Œæ€§èƒ½ä¼˜äº Mutex å¯¹è±¡ |

| ä¿¡å·é‡ | `sem\_t` | `CreateSemaphoreW` | æ”¯æŒè®¡æ•°ï¼Œé€‚åˆèµ„æºæ± ç®¡ç† |

| çº¿ç¨‹åˆ›å»º | `pthread\_create` | `\_beginthreadex` | æ­£ç¡®å¤„ç† CRTï¼Œé¿å…å†…å­˜æ³„æ¼ |

| çº¿ç¨‹ç­‰å¾… | `pthread\_join` | `WaitForSingleObject` | æ”¯æŒè¶…æ—¶ï¼Œæ›´çµæ´» |

| åŸå­æ“ä½œ | `atomic\_\*` | `volatile` + `Interlocked\*` | ç®€å•åœºæ™¯è¶³å¤Ÿ |



---



\## 2. Windows ç³»ç»Ÿè°ƒç”¨æ¸…å•



\### 2.1 ä¸´ç•ŒåŒº (CRITICAL\_SECTION)



\#### \*\*API åˆ—è¡¨\*\*



| API | åŠŸèƒ½ | å¯¹åº” POSIX | æºæ–‡ä»¶ä½ç½® |

|-----|------|-----------|-----------|

| `InitializeCriticalSection` | åˆå§‹åŒ–ä¸´ç•ŒåŒº | `pthread\_mutex\_init` | `win\_sync.cpp: 6` |

| `EnterCriticalSection` | è¿›å…¥ä¸´ç•ŒåŒºï¼ˆé˜»å¡ï¼‰ | `pthread\_mutex\_lock` | `win\_sync.cpp:14` |

| `TryEnterCriticalSection` | å°è¯•è¿›å…¥ï¼ˆéé˜»å¡ï¼‰ | `pthread\_mutex\_trylock` | `win\_sync.cpp:18` |

| `LeaveCriticalSection` | ç¦»å¼€ä¸´ç•ŒåŒº | `pthread\_mutex\_unlock` | `win\_sync.cpp:22` |

| `DeleteCriticalSection` | é”€æ¯ä¸´ç•ŒåŒº | `pthread\_mutex\_destroy` | `win\_sync.cpp:10` |



\#### \*\*å®ç°ä»£ç \*\*



```cpp

// win\_sync.cpp

class WinMutex {

public:

&nbsp;   WinMutex() {

&nbsp;       // åˆå§‹åŒ–ä¸´ç•ŒåŒºå¯¹è±¡

&nbsp;       // å‚æ•°: æŒ‡å‘ CRITICAL\_SECTION ç»“æ„çš„æŒ‡é’ˆ

&nbsp;       // è¿”å›: void

&nbsp;       InitializeCriticalSection(\&cs);

&nbsp;   }

&nbsp;   

&nbsp;   ~WinMutex() {

&nbsp;       // é‡Šæ”¾ä¸´ç•ŒåŒºå ç”¨çš„èµ„æº

&nbsp;       // æ³¨æ„:  å¿…é¡»åœ¨æ‰€æœ‰çº¿ç¨‹ç¦»å¼€ä¸´ç•ŒåŒºåè°ƒç”¨

&nbsp;       DeleteCriticalSection(\&cs);

&nbsp;   }

&nbsp;   

&nbsp;   void lock() {

&nbsp;       // é˜»å¡å¼è¿›å…¥ä¸´ç•ŒåŒº

&nbsp;       // å¦‚æœå·²è¢«å…¶ä»–çº¿ç¨‹å ç”¨ï¼Œå½“å‰çº¿ç¨‹ä¼šé˜»å¡

&nbsp;       // å†…éƒ¨å®ç°: 

&nbsp;       //   1. å¿«é€Ÿè·¯å¾„: å°è¯•åŸå­æ“ä½œè·å–é”ï¼ˆç”¨æˆ·æ€ï¼‰

&nbsp;       //   2. æ…¢é€Ÿè·¯å¾„: è°ƒç”¨å†…æ ¸å¯¹è±¡ Event è¿›è¡Œç­‰å¾…

&nbsp;       EnterCriticalSection(\&cs);

&nbsp;   }

&nbsp;   

&nbsp;   bool try\_lock() {

&nbsp;       // éé˜»å¡å¼å°è¯•è¿›å…¥ä¸´ç•ŒåŒº

&nbsp;       // è¿”å›: TRUE=æˆåŠŸ, FALSE=å·²è¢«å ç”¨

&nbsp;       // ä¼˜åŠ¿: é¿å…çº¿ç¨‹é˜»å¡ï¼Œå¯å®ç°å›é€€ç­–ç•¥

&nbsp;       return TryEnterCriticalSection(\&cs) != 0;

&nbsp;   }

&nbsp;   

&nbsp;   void unlock() {

&nbsp;       // ç¦»å¼€ä¸´ç•ŒåŒºï¼Œé‡Šæ”¾é”

&nbsp;       // æ³¨æ„: å¿…é¡»ç”±è·å¾—é”çš„çº¿ç¨‹è°ƒç”¨

&nbsp;       LeaveCriticalSection(\&cs);

&nbsp;   }

&nbsp;   

private:

&nbsp;   CRITICAL\_SECTION cs;  // Windows ä¸´ç•ŒåŒºå¯¹è±¡

};

```



\#### \*\*ä½¿ç”¨åœºæ™¯\*\*



```cpp

// åœºæ™¯1: ä¿æŠ¤å‰å­èµ„æº

struct Fork {

&nbsp;   WinMutex mtx;

&nbsp;   int holder;

&nbsp;   

&nbsp;   // å“²å­¦å®¶å°è¯•è·å–å‰å­

&nbsp;   bool try\_acquire(int phil\_id) {

&nbsp;       if (mtx.try\_lock()) {  // éé˜»å¡å°è¯•

&nbsp;           holder = phil\_id;

&nbsp;           return true;

&nbsp;       }

&nbsp;       return false;

&nbsp;   }

&nbsp;   

&nbsp;   void release() {

&nbsp;       holder = -1;

&nbsp;       mtx.unlock();

&nbsp;   }

};



// åœºæ™¯2: ä¿æŠ¤å…±äº«çŠ¶æ€

class Simulation {

private:

&nbsp;   WinMutex state\_mutex;

&nbsp;   std::vector<State> states;

&nbsp;   

public:

&nbsp;   std::vector<int> get\_states() {

&nbsp;       WinLockGuard lock(state\_mutex);  // RAII è‡ªåŠ¨ç®¡ç†

&nbsp;       // ä¸´ç•ŒåŒº:  è¯»å–å…±äº«çŠ¶æ€

&nbsp;       std::vector<int> result;

&nbsp;       for (auto s : states) {

&nbsp;           result. push\_back(static\_cast<int>(s));

&nbsp;       }

&nbsp;       return result;

&nbsp;       // lock ææ„æ—¶è‡ªåŠ¨é‡Šæ”¾é”

&nbsp;   }

};

```



\#### \*\*æ€§èƒ½ç‰¹æ€§\*\*



| ç‰¹æ€§ | è¯´æ˜ |

|------|------|

| \*\*å¿«é€Ÿè·¯å¾„\*\* | ç”¨æˆ·æ€è‡ªæ—‹é”ï¼Œæ— å†…æ ¸è°ƒç”¨ï¼ˆ~20 CPU å‘¨æœŸï¼‰ |

| \*\*æ…¢é€Ÿè·¯å¾„\*\* | å†…æ ¸ Event å¯¹è±¡é˜»å¡ï¼ˆ~1000 CPU å‘¨æœŸï¼‰ |

| \*\*é€’å½’æ”¯æŒ\*\* | ä¸æ”¯æŒé€’å½’ï¼ˆä¸ POSIX é»˜è®¤è¡Œä¸ºä¸€è‡´ï¼‰ |

| \*\*ä¼˜å…ˆçº§ç»§æ‰¿\*\* | ä¸æ”¯æŒï¼ˆå¯èƒ½å¯¼è‡´ä¼˜å…ˆçº§åè½¬ï¼‰ |

| \*\*å…¬å¹³æ€§\*\* | æ— ä¿è¯ï¼ˆå¯èƒ½é¥¥é¥¿ï¼‰ |



---



\### 2.2 ä¿¡å·é‡ (Semaphore)



\#### \*\*API åˆ—è¡¨\*\*



| API | åŠŸèƒ½ | å¯¹åº” POSIX | æºæ–‡ä»¶ä½ç½® |

|-----|------|-----------|-----------|

| `CreateSemaphoreW` | åˆ›å»ºä¿¡å·é‡ | `sem\_init` | `win\_sync.cpp:27` |

| `WaitForSingleObject` | ç­‰å¾…ä¿¡å·é‡ï¼ˆP æ“ä½œï¼‰ | `sem\_wait` | `win\_sync.cpp:40` |

| `ReleaseSemaphore` | é‡Šæ”¾ä¿¡å·é‡ï¼ˆV æ“ä½œï¼‰ | `sem\_post` | `win\_sync.cpp:48` |

| `CloseHandle` | é”€æ¯ä¿¡å·é‡ | `sem\_destroy` | `win\_sync.cpp:35` |



\#### \*\*å®ç°ä»£ç \*\*



```cpp

// win\_sync.cpp

class WinSemaphore {

public: 

&nbsp;   WinSemaphore(long initial\_count = 0, long max\_count = 1) {

&nbsp;       // åˆ›å»ºå‘½åæˆ–åŒ¿åä¿¡å·é‡

&nbsp;       // å‚æ•°: 

&nbsp;       //   - lpSemaphoreAttributes: å®‰å…¨å±æ€§ï¼ˆNULL=é»˜è®¤ï¼‰

&nbsp;       //   - lInitialCount: åˆå§‹è®¡æ•°å€¼

&nbsp;       //   - lMaximumCount: æœ€å¤§è®¡æ•°å€¼

&nbsp;       //   - lpName: ä¿¡å·é‡åç§°ï¼ˆNULL=åŒ¿åï¼‰

&nbsp;       // è¿”å›: ä¿¡å·é‡å¥æŸ„

&nbsp;       handle = CreateSemaphoreW(

&nbsp;           NULL,           // é»˜è®¤å®‰å…¨å±æ€§

&nbsp;           initial\_count,  // åˆå§‹è®¡æ•°

&nbsp;           max\_count,      // æœ€å¤§è®¡æ•°

&nbsp;           NULL            // åŒ¿åä¿¡å·é‡

&nbsp;       );

&nbsp;       

&nbsp;       if (handle == NULL) {

&nbsp;           throw std::runtime\_error("CreateSemaphore failed");

&nbsp;       }

&nbsp;   }

&nbsp;   

&nbsp;   ~WinSemaphore() {

&nbsp;       if (handle != NULL) {

&nbsp;           // å…³é—­ä¿¡å·é‡å¥æŸ„ï¼Œé‡Šæ”¾å†…æ ¸å¯¹è±¡

&nbsp;           CloseHandle(handle);

&nbsp;       }

&nbsp;   }

&nbsp;   

&nbsp;   void wait() {

&nbsp;       // P æ“ä½œï¼šç­‰å¾…ä¿¡å·é‡ï¼ˆè®¡æ•°å‡ 1ï¼‰

&nbsp;       // å¦‚æœè®¡æ•°ä¸º 0ï¼Œåˆ™é˜»å¡å½“å‰çº¿ç¨‹

&nbsp;       // å‚æ•°:

&nbsp;       //   - hHandle: ä¿¡å·é‡å¥æŸ„

&nbsp;       //   - dwMilliseconds: è¶…æ—¶æ—¶é—´ï¼ˆINFINITE=æ— é™ç­‰å¾…ï¼‰

&nbsp;       // è¿”å›:  WAIT\_OBJECT\_0=æˆåŠŸ, WAIT\_TIMEOUT=è¶…æ—¶

&nbsp;       WaitForSingleObject(handle, INFINITE);

&nbsp;   }

&nbsp;   

&nbsp;   bool try\_wait(DWORD timeout\_ms = 0) {

&nbsp;       // å¸¦è¶…æ—¶çš„ P æ“ä½œ

&nbsp;       // timeout\_ms=0: éé˜»å¡å°è¯•

&nbsp;       return WaitForSingleObject(handle, timeout\_ms) == WAIT\_OBJECT\_0;

&nbsp;   }

&nbsp;   

&nbsp;   void post() {

&nbsp;       // V æ“ä½œï¼šé‡Šæ”¾ä¿¡å·é‡ï¼ˆè®¡æ•°åŠ  1ï¼‰

&nbsp;       // å‚æ•°:

&nbsp;       //   - hSemaphore: ä¿¡å·é‡å¥æŸ„

&nbsp;       //   - lReleaseCount: å¢åŠ çš„è®¡æ•°ï¼ˆé€šå¸¸ä¸º 1ï¼‰

&nbsp;       //   - lpPreviousCount: è¿”å›ä¹‹å‰çš„è®¡æ•°ï¼ˆNULL=å¿½ç•¥ï¼‰

&nbsp;       // è¿”å›: TRUE=æˆåŠŸ

&nbsp;       ReleaseSemaphore(handle, 1, NULL);

&nbsp;   }

&nbsp;   

private: 

&nbsp;   HANDLE handle;  // ä¿¡å·é‡å†…æ ¸å¯¹è±¡å¥æŸ„

};

```



\#### \*\*ä½¿ç”¨åœºæ™¯\*\*



```cpp

// åœºæ™¯1: èµ„æºæ± ç®¡ç†ï¼ˆæœªæ¿€æ´»ä½¿ç”¨ï¼‰

class ForkPool {

private:

&nbsp;   WinSemaphore available\_forks;  // å¯ç”¨å‰å­è®¡æ•°

&nbsp;   

public:

&nbsp;   ForkPool(int num\_forks) 

&nbsp;       : available\_forks(num\_forks, num\_forks) {}

&nbsp;   

&nbsp;   bool try\_acquire() {

&nbsp;       return available\_forks.try\_wait(0);  // éé˜»å¡å°è¯•

&nbsp;   }

&nbsp;   

&nbsp;   void release() {

&nbsp;       available\_forks.post();

&nbsp;   }

};



// åœºæ™¯2: ç”Ÿäº§è€…-æ¶ˆè´¹è€…ï¼ˆäº‹ä»¶é˜Ÿåˆ—ï¼‰

class EventQueue {

private:

&nbsp;   WinSemaphore items;       // å·²æœ‰é¡¹ç›®æ•°

&nbsp;   WinSemaphore spaces;      // å‰©ä½™ç©ºé—´æ•°

&nbsp;   WinMutex queue\_mutex;     // ä¿æŠ¤é˜Ÿåˆ—

&nbsp;   std::deque<Event> queue;

&nbsp;   

public:

&nbsp;   void produce(Event e) {

&nbsp;       spaces.wait();            // ç­‰å¾…ç©ºé—´

&nbsp;       {

&nbsp;           WinLockGuard lock(queue\_mutex);

&nbsp;           queue.push\_back(e);

&nbsp;       }

&nbsp;       items.post();             // å¢åŠ é¡¹ç›®è®¡æ•°

&nbsp;   }

&nbsp;   

&nbsp;   Event consume() {

&nbsp;       items.wait();             // ç­‰å¾…é¡¹ç›®

&nbsp;       Event e;

&nbsp;       {

&nbsp;           WinLockGuard lock(queue\_mutex);

&nbsp;           e = queue.front();

&nbsp;           queue.pop\_front();

&nbsp;       }

&nbsp;       spaces.post();            // å¢åŠ ç©ºé—´è®¡æ•°

&nbsp;       return e;

&nbsp;   }

};

```



\#### \*\*æ€§èƒ½ç‰¹æ€§\*\*



| ç‰¹æ€§ | è¯´æ˜ |

|------|------|

| \*\*å†…æ ¸å¯¹è±¡\*\* | æ¯æ¬¡æ“ä½œéƒ½æ¶‰åŠå†…æ ¸è°ƒç”¨ï¼ˆ~1000 CPU å‘¨æœŸï¼‰ |

| \*\*æ”¯æŒè¶…æ—¶\*\* | å¯è®¾ç½®ç­‰å¾…è¶…æ—¶ï¼Œé¿å…æ°¸ä¹…é˜»å¡ |

| \*\*è¿›ç¨‹é—´å…±äº«\*\* | æ”¯æŒå‘½åä¿¡å·é‡è·¨è¿›ç¨‹é€šä¿¡ |

| \*\*æœ€å¤§è®¡æ•°\*\* | å¯é™åˆ¶èµ„æºæ€»æ•° |

| \*\*å…¬å¹³æ€§\*\* | FIFO é˜Ÿåˆ—ï¼Œä¿è¯å…¬å¹³ |



---



\### 2.3 çº¿ç¨‹ç®¡ç†



\#### \*\*API åˆ—è¡¨\*\*



| API | åŠŸèƒ½ | å¯¹åº” POSIX | æºæ–‡ä»¶ä½ç½® |

|-----|------|-----------|-----------|

| `\_beginthreadex` | åˆ›å»ºçº¿ç¨‹ | `pthread\_create` | `win\_sync.cpp:74` |

| `WaitForSingleObject` | ç­‰å¾…çº¿ç¨‹ç»“æŸ | `pthread\_join` | `win\_sync.cpp:60` |

| `CloseHandle` | å…³é—­çº¿ç¨‹å¥æŸ„ | - | `win\_sync.cpp:54` |



\#### \*\*å®ç°ä»£ç \*\*



```cpp

// win\_sync.cpp

class WinThread {

public:

&nbsp;   WinThread() :  handle(NULL) {}

&nbsp;   

&nbsp;   ~WinThread() {

&nbsp;       if (handle != NULL) {

&nbsp;           CloseHandle(handle);

&nbsp;       }

&nbsp;   }

&nbsp;   

&nbsp;   template<typename Func>

&nbsp;   void start(Func\&\& func) {

&nbsp;       // åŒ…è£… Lambda ä¸º std::function

&nbsp;       auto\* wrapper = new std::function<void()>(

&nbsp;           std::forward<Func>(func)

&nbsp;       );

&nbsp;       

&nbsp;       // åˆ›å»ºçº¿ç¨‹

&nbsp;       // å‚æ•°:

&nbsp;       //   - security: å®‰å…¨å±æ€§ï¼ˆNULL=é»˜è®¤ï¼‰

&nbsp;       //   - stack\_size: æ ˆå¤§å°ï¼ˆ0=é»˜è®¤ 1MBï¼‰

&nbsp;       //   - start\_address: çº¿ç¨‹å‡½æ•°

&nbsp;       //   - arglist: ä¼ é€’ç»™çº¿ç¨‹å‡½æ•°çš„å‚æ•°

&nbsp;       //   - initflag: åˆå§‹åŒ–æ ‡å¿—ï¼ˆ0=ç«‹å³è¿è¡Œï¼‰

&nbsp;       //   - thrdaddr: è¿”å›çº¿ç¨‹ IDï¼ˆNULL=å¿½ç•¥ï¼‰

&nbsp;       // è¿”å›: çº¿ç¨‹å¥æŸ„

&nbsp;       handle = (HANDLE)\_beginthreadex(

&nbsp;           NULL,                // é»˜è®¤å®‰å…¨å±æ€§

&nbsp;           0,                   // é»˜è®¤æ ˆå¤§å°

&nbsp;           thread\_proc,         // çº¿ç¨‹å…¥å£

&nbsp;           wrapper,             // å‚æ•°

&nbsp;           0,                   // ç«‹å³è¿è¡Œ

&nbsp;           NULL                 // ä¸éœ€è¦çº¿ç¨‹ ID

&nbsp;       );

&nbsp;   }

&nbsp;   

&nbsp;   void join() {

&nbsp;       if (handle != NULL) {

&nbsp;           // ç­‰å¾…çº¿ç¨‹ç»“æŸ

&nbsp;           WaitForSingleObject(handle, INFINITE);

&nbsp;           CloseHandle(handle);

&nbsp;           handle = NULL;

&nbsp;       }

&nbsp;   }

&nbsp;   

&nbsp;   bool joinable() const {

&nbsp;       return handle != NULL;

&nbsp;   }

&nbsp;   

private:

&nbsp;   HANDLE handle;

&nbsp;   

&nbsp;   // çº¿ç¨‹å…¥å£å‡½æ•°ï¼ˆå¿…é¡»æ˜¯ \_\_stdcallï¼‰

&nbsp;   static unsigned int \_\_stdcall thread\_proc(void\* arg) {

&nbsp;       auto\* func = static\_cast<std::function<void()>\*>(arg);

&nbsp;       (\*func)();      // æ‰§è¡Œç”¨æˆ·å‡½æ•°

&nbsp;       delete func;    // é‡Šæ”¾å†…å­˜

&nbsp;       return 0;

&nbsp;   }

};

```



\#### \*\*ä½¿ç”¨åœºæ™¯\*\*



```cpp

// åœºæ™¯:  å“²å­¦å®¶çº¿ç¨‹æ± 

class Simulation {

private:

&nbsp;   std::vector<std::unique\_ptr<WinThread>> threads;

&nbsp;   

public:

&nbsp;   void start() {

&nbsp;       for (int i = 0; i < num\_philosophers; ++i) {

&nbsp;           auto t = std::make\_unique<WinThread>();

&nbsp;           

&nbsp;           // å¯åŠ¨çº¿ç¨‹ï¼Œä¼ é€’ Lambda

&nbsp;           t->start(\[this, i]() {

&nbsp;               this->philosopher\_thread(i);

&nbsp;           });

&nbsp;           

&nbsp;           threads.push\_back(std::move(t));

&nbsp;       }

&nbsp;   }

&nbsp;   

&nbsp;   void stop() {

&nbsp;       running = false;

&nbsp;       

&nbsp;       // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹ç»“æŸ

&nbsp;       for (auto\& t : threads) {

&nbsp;           if (t->joinable()) {

&nbsp;               t->join();

&nbsp;           }

&nbsp;       }

&nbsp;       

&nbsp;       threads.clear();

&nbsp;   }

};

```



\#### \*\*ä¸ºä»€ä¹ˆä½¿ç”¨ `\_beginthreadex` è€Œé `CreateThread`ï¼Ÿ\*\*



| å¯¹æ¯”é¡¹ | `CreateThread` | `\_beginthreadex` |

|--------|---------------|-----------------|

| \*\*CRT åˆå§‹åŒ–\*\* | âŒ ä¸åˆå§‹åŒ– | âœ… æ­£ç¡®åˆå§‹åŒ– |

| \*\*å†…å­˜æ³„æ¼\*\* | âš ï¸ å¯èƒ½æ³„æ¼ | âœ… æ— æ³„æ¼ |

| \*\*çº¿ç¨‹å±€éƒ¨å­˜å‚¨\*\* | âŒ ä¸æ”¯æŒ | âœ… æ”¯æŒ |

| \*\*æ¨èä½¿ç”¨\*\* | âŒ ä¸æ¨è | âœ… æ¨è |



---



\## 3. åŒæ­¥åŸè¯­å®ç°



\### 3.1 RAII é”å®ˆå«



```cpp

// win\_sync.h

class WinLockGuard {

public:

&nbsp;   explicit WinLockGuard(WinMutex\& m) : mutex(m) {

&nbsp;       mutex.lock();  // æ„é€ æ—¶è‡ªåŠ¨åŠ é”

&nbsp;   }

&nbsp;   

&nbsp;   ~WinLockGuard() {

&nbsp;       mutex.unlock();  // ææ„æ—¶è‡ªåŠ¨è§£é”

&nbsp;   }

&nbsp;   

&nbsp;   // ç¦æ­¢æ‹·è´å’Œç§»åŠ¨

&nbsp;   WinLockGuard(const WinLockGuard\&) = delete;

&nbsp;   WinLockGuard\& operator=(const WinLockGuard\&) = delete;

&nbsp;   

private:

&nbsp;   WinMutex\& mutex;

};



// ä½¿ç”¨ç¤ºä¾‹

void Simulation::get\_states() {

&nbsp;   WinLockGuard lock(state\_mutex);  // è‡ªåŠ¨åŠ é”

&nbsp;   

&nbsp;   // ä¸´ç•ŒåŒºä»£ç 

&nbsp;   // å³ä½¿æŠ›å‡ºå¼‚å¸¸ï¼Œlock ä¹Ÿä¼šåœ¨ææ„æ—¶è‡ªåŠ¨è§£é”

&nbsp;   

&nbsp;   // å‡½æ•°è¿”å›æ—¶è‡ªåŠ¨è§£é”

}

```



\*\*ä¼˜åŠ¿\*\*: 

\- âœ… å¼‚å¸¸å®‰å…¨ï¼šå³ä½¿æŠ›å‡ºå¼‚å¸¸ä¹Ÿèƒ½æ­£ç¡®è§£é”

\- âœ… é˜²æ­¢å¿˜è®°è§£é”

\- âœ… è‡ªåŠ¨ç®¡ç†é”ç”Ÿå‘½å‘¨æœŸ



---



\### 3.2 åŸå­æ“ä½œ



```cpp

// simulation.h

class Simulation {

private: 

&nbsp;   volatile bool running;  // çº¿ç¨‹å…±äº«æ ‡å¿—

&nbsp;   

public:

&nbsp;   void stop() {

&nbsp;       running = false;  // å†™æ“ä½œ

&nbsp;       // ... 

&nbsp;   }

&nbsp;   

&nbsp;   void philosopher\_thread(int id) {

&nbsp;       while (running) {  // è¯»æ“ä½œ

&nbsp;           // ...

&nbsp;       }

&nbsp;   }

};

```



\*\*æ³¨æ„äº‹é¡¹\*\*:

\- `volatile` ç¡®ä¿ç¼–è¯‘å™¨ä¸ä¼˜åŒ–è¯»å†™æ“ä½œ

\- ç®€å•çš„å¸ƒå°”æ ‡å¿—è¶³å¤Ÿï¼Œæ— éœ€å¤æ‚åŸå­æ“ä½œ

\- å¯¹äºå¤æ‚åœºæ™¯ï¼Œå¯ä½¿ç”¨ `InterlockedIncrement` ç­‰



---



\## 4. åŒæ­¥åœºæ™¯åˆ†æ



\### 4.1 åœºæ™¯1: è·å–å‰å­ï¼ˆæ ¸å¿ƒåŒæ­¥åœºæ™¯ï¼‰



```cpp

void Simulation::philosopher\_thread(int id) {

&nbsp;   int left = ... ;

&nbsp;   int right = ...;

&nbsp;   

&nbsp;   while (running) {

&nbsp;       // ===== é˜¶æ®µ1: THINKING =====

&nbsp;       {

&nbsp;           WinLockGuard lock(state\_mutex);  // ğŸ”’ é”1:  ä¿æŠ¤çŠ¶æ€

&nbsp;           states\[id] = State::THINKING;

&nbsp;       }  // ğŸ”“ è‡ªåŠ¨è§£é”

&nbsp;       Sleep(thinking\_time);

&nbsp;       

&nbsp;       // ===== é˜¶æ®µ2: HUNGRY =====

&nbsp;       {

&nbsp;           WinLockGuard lock(state\_mutex);  // ğŸ”’ é”1: ä¿æŠ¤çŠ¶æ€

&nbsp;           states\[id] = State:: HUNGRY;

&nbsp;           wait\_counts\[id] = 0;

&nbsp;       }  // ğŸ”“ è‡ªåŠ¨è§£é”

&nbsp;       

&nbsp;       // ===== é˜¶æ®µ3: å°è¯•è·å–å‰å­ =====

&nbsp;       bool has\_eaten = false;

&nbsp;       while (running \&\& !has\_eaten) {

&nbsp;           // 3.1 è¯·æ±‚å·¦å‰å­

&nbsp;           if (request\_permission(id, left)) {  // ç­–ç•¥æ£€æŸ¥ï¼ˆæŒæœ‰ state\_mutexï¼‰

&nbsp;               

&nbsp;               // 3.2 å°è¯•è·å–å·¦å‰å­é”

&nbsp;               if (forks\[left]->mtx.try\_lock()) {  // ğŸ”’ é”2: å·¦å‰å­ï¼ˆéé˜»å¡ï¼‰

&nbsp;                   forks\[left]->holder = id;

&nbsp;                   log\_event(id, "ACQUIRE", "Left Fork");

&nbsp;                   

&nbsp;                   Sleep(10);  // æ¨¡æ‹Ÿå»¶è¿Ÿ

&nbsp;                   

&nbsp;                   // 3.3 è¯·æ±‚å³å‰å­

&nbsp;                   if (request\_permission(id, right)) {

&nbsp;                       

&nbsp;                       // 3.4 å°è¯•è·å–å³å‰å­é”

&nbsp;                       if (forks\[right]->mtx.try\_lock()) {  // ğŸ”’ é”3: å³å‰å­ï¼ˆéé˜»å¡ï¼‰

&nbsp;                           forks\[right]->holder = id;

&nbsp;                           log\_event(id, "ACQUIRE", "Right Fork");

&nbsp;                           

&nbsp;                           // ===== é˜¶æ®µ4: EATING =====

&nbsp;                           {

&nbsp;                               WinLockGuard lock(state\_mutex);  // ğŸ”’ é”1: ä¿æŠ¤çŠ¶æ€

&nbsp;                               states\[id] = State:: EATING;

&nbsp;                               eat\_counts\[id]++;

&nbsp;                           }  // ğŸ”“ è‡ªåŠ¨è§£é”

&nbsp;                           

&nbsp;                           Sleep(eating\_time);  // ğŸ è¿›é¤

&nbsp;                           

&nbsp;                           // ===== é˜¶æ®µ5: é‡Šæ”¾å‰å­ =====

&nbsp;                           forks\[right]->holder = -1;

&nbsp;                           forks\[right]->mtx.unlock();  // ğŸ”“ è§£é”3

&nbsp;                           

&nbsp;                           forks\[left]->holder = -1;

&nbsp;                           forks\[left]->mtx. unlock();  // ğŸ”“ è§£é”2

&nbsp;                           

&nbsp;                           has\_eaten = true;

&nbsp;                           

&nbsp;                       } else {

&nbsp;                           // å³å‰å­è·å–å¤±è´¥ï¼Œå›é€€

&nbsp;                           forks\[left]->holder = -1;

&nbsp;                           forks\[left]->mtx.unlock();  // ğŸ”“ è§£é”2

&nbsp;                       }

&nbsp;                   } else {

&nbsp;                       // ç­–ç•¥æ‹’ç»å³å‰å­ï¼Œå›é€€

&nbsp;                       forks\[left]->holder = -1;

&nbsp;                       forks\[left]->mtx.unlock();  // ğŸ”“ è§£é”2

&nbsp;                   }

&nbsp;               }

&nbsp;           }

&nbsp;           

&nbsp;           // 3.5 è·å–å¤±è´¥ï¼Œå¢åŠ ç­‰å¾…è®¡æ•°

&nbsp;           if (!has\_eaten) {

&nbsp;               WinLockGuard lock(state\_mutex);  // ğŸ”’ é”1

&nbsp;               wait\_counts\[id]++;

&nbsp;           }  // ğŸ”“ è‡ªåŠ¨è§£é”

&nbsp;           

&nbsp;           Sleep(50);  // é¿å…å¿™ç­‰

&nbsp;       }

&nbsp;   }

}

```



\*\*å…³é”®ç‚¹\*\*:

1\. \*\*ä¸‰çº§é”\*\*:  `state\_mutex` â†’ `left\_fork. mtx` â†’ `right\_fork.mtx`

2\. \*\*éé˜»å¡è·å–\*\*:  ä½¿ç”¨ `try\_lock()` é¿å…æ­»é”

3\. \*\*å›é€€ç­–ç•¥\*\*: è·å–å¤±è´¥æ—¶ç«‹å³é‡Šæ”¾å·²è·å¾—çš„é”

4\. \*\*é”ç²’åº¦\*\*: æœ€å°åŒ–é”æŒæœ‰æ—¶é—´



---



\### 4.2 åœºæ™¯2: äº‹ä»¶æ—¥å¿—ï¼ˆç”Ÿäº§è€…-æ¶ˆè´¹è€…ï¼‰



```cpp

// ç”Ÿäº§è€…:  å“²å­¦å®¶çº¿ç¨‹

void Simulation::log\_event(int phil\_id, const std::string\& type, 

&nbsp;                           const std::string\& details) {

&nbsp;   WinLockGuard lock(event\_mutex);  // ğŸ”’ ä¿æŠ¤é˜Ÿåˆ—

&nbsp;   

&nbsp;   auto now = std::chrono::system\_clock::now().time\_since\_epoch();

&nbsp;   double ts = std::chrono::duration<double>(now).count();

&nbsp;   

&nbsp;   event\_queue.push\_back({ts, phil\_id, type, details});

&nbsp;   

&nbsp;   // é˜Ÿåˆ—æ»¡è½½ä¿æŠ¤

&nbsp;   if (event\_queue.size() > 5000) {

&nbsp;       event\_queue. pop\_front();  // ä¸¢å¼ƒæœ€æ—§çš„äº‹ä»¶

&nbsp;   }

}  // ğŸ”“ è‡ªåŠ¨è§£é”



// æ¶ˆè´¹è€…: GUI çº¿ç¨‹

std::vector<SimEvent> Simulation::poll\_events() {

&nbsp;   WinLockGuard lock(event\_mutex);  // ğŸ”’ ä¿æŠ¤é˜Ÿåˆ—

&nbsp;   

&nbsp;   // å¤åˆ¶æ‰€æœ‰äº‹ä»¶

&nbsp;   std::vector<SimEvent> events(event\_queue.begin(), event\_queue.end());

&nbsp;   

&nbsp;   // æ¸…ç©ºé˜Ÿåˆ—

&nbsp;   event\_queue.clear();

&nbsp;   

&nbsp;   return events;

}  // ğŸ”“ è‡ªåŠ¨è§£é”

```



\*\*ç‰¹ç‚¹\*\*:

\- âœ… å¤šç”Ÿäº§è€…ï¼ˆN ä¸ªå“²å­¦å®¶çº¿ç¨‹ï¼‰

\- âœ… å•æ¶ˆè´¹è€…ï¼ˆGUI çº¿ç¨‹ï¼‰

\- âœ… æœ‰ç•Œé˜Ÿåˆ—ï¼ˆæœ€å¤š 5000 æ¡ï¼‰

\- âœ… æ‰¹é‡è¯»å–ï¼ˆå‡å°‘é”ç«äº‰ï¼‰



---



\### 4.3 åœºæ™¯3: çŠ¶æ€æŸ¥è¯¢ï¼ˆè¯»å¤šå†™å°‘ï¼‰



```cpp

// å†™æ“ä½œï¼ˆå°‘ï¼‰

void philosopher\_thread(int id) {

&nbsp;   WinLockGuard lock(state\_mutex);

&nbsp;   states\[id] = State::EATING;  // å†™å…¥

}



// è¯»æ“ä½œï¼ˆå¤šï¼‰

std::vector<int> Simulation::get\_states() {

&nbsp;   WinLockGuard lock(state\_mutex);

&nbsp;   

&nbsp;   std::vector<int> result;

&nbsp;   for (auto s : states) {

&nbsp;       result.push\_back(static\_cast<int>(s));  // è¯»å–

&nbsp;   }

&nbsp;   

&nbsp;   return result;

}

```



\*\*ä¼˜åŒ–ç©ºé—´\*\*:

\- âš ï¸ å½“å‰ä½¿ç”¨äº’æ–¥é”ï¼ˆè¯»å†™éƒ½ç‹¬å ï¼‰

\- ğŸ’¡ å¯æ”¹ç”¨è¯»å†™é”ï¼ˆ`SRWLock`ï¼‰æå‡å¹¶å‘è¯»æ€§èƒ½



```cpp

// æ½œåœ¨ä¼˜åŒ–ï¼ˆæœªå®ç°ï¼‰

class Simulation {

private:

&nbsp;   SRWLOCK state\_rwlock;  // è¯»å†™é”

&nbsp;   

public:

&nbsp;   void set\_state(int id, State s) {

&nbsp;       AcquireSRWLockExclusive(\&state\_rwlock);  // å†™é”

&nbsp;       states\[id] = s;

&nbsp;       ReleaseSRWLockExclusive(\&state\_rwlock);

&nbsp;   }

&nbsp;   

&nbsp;   std::vector<int> get\_states() {

&nbsp;       AcquireSRWLockShared(\&state\_rwlock);  // è¯»é”ï¼ˆå…è®¸å¹¶å‘ï¼‰

&nbsp;       // ...  è¯»å–æ“ä½œ

&nbsp;       ReleaseSRWLockShared(\&state\_rwlock);

&nbsp;   }

};

```



---



\## 5. æ­»é”é¿å…æœºåˆ¶



\### 5.1 é“¶è¡Œå®¶ç®—æ³•å®ç°



```cpp

bool Simulation::is\_safe\_state(int phil\_id, int fork\_id) {

&nbsp;   // 1. åˆå§‹åŒ–èµ„æºå¯ç”¨æ€§å’Œéœ€æ±‚

&nbsp;   std::vector<int> available(num\_forks, 1);

&nbsp;   std::vector<int> need(num\_philosophers, 2);  // æ¯äººéœ€è¦ 2 æŠŠå‰å­

&nbsp;   

&nbsp;   // 2. æ ‡è®°å·²åˆ†é…èµ„æº

&nbsp;   for (int i = 0; i < num\_forks; ++i) {

&nbsp;       int holder = forks\[i]->holder;

&nbsp;       if (holder != -1) {

&nbsp;           available\[i] = 0;       // å‰å­ä¸å¯ç”¨

&nbsp;           need\[holder]--;         // æŒæœ‰è€…éœ€æ±‚å‡ 1

&nbsp;       }

&nbsp;   }

&nbsp;   

&nbsp;   // 3. æ¨¡æ‹Ÿåˆ†é…è¯·æ±‚çš„å‰å­

&nbsp;   if (available\[fork\_id] == 0) return false;

&nbsp;   available\[fork\_id] = 0;

&nbsp;   need\[phil\_id]--;

&nbsp;   

&nbsp;   // 4. å°è¯•æ‰¾åˆ°å®‰å…¨åºåˆ—

&nbsp;   std::vector<bool> finish(num\_philosophers, false);

&nbsp;   int finished\_count = 0;

&nbsp;   

&nbsp;   while (finished\_count < num\_philosophers) {

&nbsp;       bool found = false;

&nbsp;       

&nbsp;       for (int i = 0; i < num\_philosophers; ++i) {

&nbsp;           if (!finish\[i]) {

&nbsp;               // æ£€æŸ¥æ˜¯å¦èƒ½æ»¡è¶³è¯¥å“²å­¦å®¶çš„éœ€æ±‚

&nbsp;               if (need\[i] <= 0) {

&nbsp;                   finish\[i] = true;

&nbsp;                   finished\_count++;

&nbsp;                   found = true;

&nbsp;               } else {

&nbsp;                   // æ£€æŸ¥èƒ½å¦è·å¾—æ‰€éœ€å‰å­

&nbsp;                   int left = ... ;

&nbsp;                   int right = ... ;

&nbsp;                   

&nbsp;                   bool left\_ok = (forks\[left]->holder == i) || 

&nbsp;                                  (available\[left] == 1);

&nbsp;                   bool right\_ok = (forks\[right]->holder == i) || 

&nbsp;                                   (available\[right] == 1);

&nbsp;                   

&nbsp;                   if (left\_ok \&\& right\_ok) {

&nbsp;                       // æ¨¡æ‹Ÿå®Œæˆå¹¶é‡Šæ”¾èµ„æº

&nbsp;                       finish\[i] = true;

&nbsp;                       finished\_count++;

&nbsp;                       found = true;

&nbsp;                       

&nbsp;                       // é‡Šæ”¾è¯¥å“²å­¦å®¶å ç”¨çš„èµ„æº

&nbsp;                       if (forks\[left]->holder == i) available\[left] = 1;

&nbsp;                       if (forks\[right]->holder == i) available\[right] = 1;

&nbsp;                   }

&nbsp;               }

&nbsp;           }

&nbsp;       }

&nbsp;       

&nbsp;       // 5. å¦‚æœä¸€è½®ä¸‹æ¥æ²¡æœ‰è¿›å±•ï¼Œè¯´æ˜å­˜åœ¨æ­»é”é£é™©

&nbsp;       if (!found) return false;

&nbsp;   }

&nbsp;   

&nbsp;   // 6. æ‰€æœ‰å“²å­¦å®¶éƒ½èƒ½å®Œæˆï¼ŒçŠ¶æ€å®‰å…¨

&nbsp;   return true;

}

```



\*\*ç®—æ³•å¤æ‚åº¦\*\*: O(NÂ²) (N=å“²å­¦å®¶æ•°é‡)



---



\### 5.2 åé¥¥é¥¿æœºåˆ¶



```cpp

bool Simulation::request\_permission(int phil\_id, int fork\_id) {

&nbsp;   WinLockGuard lock(state\_mutex);

&nbsp;   

&nbsp;   // 1. æ£€æŸ¥å‰å­æ˜¯å¦è¢«å ç”¨

&nbsp;   if (forks\[fork\_id]->holder != -1) return false;

&nbsp;   

&nbsp;   // 2. åé¥¥é¥¿æ£€æŸ¥

&nbsp;   for (int comp\_id :  competitors\[phil\_id]) {

&nbsp;       if (states\[comp\_id] == State:: HUNGRY \&\&

&nbsp;           wait\_counts\[comp\_id] > STARVATION\_THRESHOLD \&\&

&nbsp;           wait\_counts\[comp\_id] > wait\_counts\[phil\_id]) {

&nbsp;           // ç¤¼è®©æ›´é¥¥é¥¿çš„ç«äº‰è€…

&nbsp;           return false;

&nbsp;       }

&nbsp;   }

&nbsp;   

&nbsp;   // 3. åº”ç”¨ Banker's Algorithm

&nbsp;   if (current\_strategy == Strategy::BANKER) {

&nbsp;       return is\_safe\_state(phil\_id, fork\_id);

&nbsp;   }

&nbsp;   

&nbsp;   return true;  // æ— ç­–ç•¥æ—¶ç›´æ¥å…è®¸

}

```



\*\*æœºåˆ¶è¯´æ˜\*\*:

\- \*\*ç«äº‰è€…è¯†åˆ«\*\*: ä»»ä½•å…±äº«å‰å­çš„å“²å­¦å®¶äº’ä¸ºç«äº‰è€…

\- \*\*é¥¥é¥¿é˜ˆå€¼\*\*: `STARVATION\_THRESHOLD = 10`ï¼ˆå¤±è´¥ 10 æ¬¡ï¼‰

\- \*\*ä¼˜å…ˆçº§\*\*:  ç­‰å¾…æ—¶é—´è¶Šé•¿ï¼Œä¼˜å…ˆçº§è¶Šé«˜



---



\### 5.3 æ­»é”æ£€æµ‹ï¼ˆRAG ç¯æ£€æµ‹ï¼‰



```cpp

bool Simulation::detect\_deadlock() {

&nbsp;   WinLockGuard lock(state\_mutex);

&nbsp;   

&nbsp;   // 1. æ„å»ºç­‰å¾…å›¾ (Philosopher â†’ Philosopher)

&nbsp;   std::map<int, int> waiting\_for;

&nbsp;   

&nbsp;   for (int i = 0; i < num\_philosophers; ++i) {

&nbsp;       if (states\[i] == State::HUNGRY) {

&nbsp;           int left = ...;

&nbsp;           int right = ...;

&nbsp;           

&nbsp;           // å¦‚æœå“²å­¦å®¶ç­‰å¾…æŸæŠŠå‰å­ï¼Œè€Œè¯¥å‰å­ç”±å¦ä¸€å“²å­¦å®¶æŒæœ‰

&nbsp;           if (forks\[left]->holder != i \&\& forks\[left]->holder != -1) {

&nbsp;               waiting\_for\[i] = forks\[left]->holder;

&nbsp;           } else if (forks\[right]->holder != i \&\& forks\[right]->holder != -1) {

&nbsp;               waiting\_for\[i] = forks\[right]->holder;

&nbsp;           }

&nbsp;       }

&nbsp;   }

&nbsp;   

&nbsp;   // 2. æ£€æµ‹ç¯è·¯

&nbsp;   for (auto const\& \[start\_node, \_] : waiting\_for) {

&nbsp;       int curr = start\_node;

&nbsp;       std::vector<int> visited;

&nbsp;       

&nbsp;       while (waiting\_for.count(curr)) {

&nbsp;           visited.push\_back(curr);

&nbsp;           curr = waiting\_for\[curr];

&nbsp;           

&nbsp;           // å‘ç°ç¯è·¯

&nbsp;           if (std::find(visited.begin(), visited.end(), curr) != visited.end()) {

&nbsp;               log\_event(-1, "DEADLOCK", "Cycle detected");

&nbsp;               return true;

&nbsp;           }

&nbsp;       }

&nbsp;   }

&nbsp;   

&nbsp;   return false;

}

```



\*\*ç®—æ³•\*\*: DFS ç¯æ£€æµ‹ï¼Œå¤æ‚åº¦ O(N)



---



\## 6. æ€§èƒ½ä¼˜åŒ–



\### 6.1 é”ä¼˜åŒ–ç­–ç•¥



| ç­–ç•¥ | å®ç° | æ•ˆæœ |

|------|------|------|

| \*\*æœ€å°é”ç²’åº¦\*\* | æ¯ä¸ªå‰å­ç‹¬ç«‹é” | æœ€å¤§åŒ–å¹¶è¡Œåº¦ |

| \*\*éé˜»å¡è·å–\*\* | `try\_lock()` | é¿å…çº¿ç¨‹é˜»å¡ |

| \*\*çŸ­é”æŒæœ‰\*\* | ä¸´ç•ŒåŒºæœ€å°åŒ– | å‡å°‘é”ç«äº‰ |

| \*\*è¯»å†™åˆ†ç¦»\*\* | ï¼ˆæœªå®ç°ï¼‰è¯»å†™é” | æå‡è¯»å¹¶å‘ |

| \*\*æ— é”é˜Ÿåˆ—\*\* | ï¼ˆæœªå®ç°ï¼‰ç¯å½¢ç¼“å†² | æ¶ˆé™¤é”å¼€é”€ |



\### 6.2 æ€§èƒ½æµ‹é‡



```cpp

// æ½œåœ¨æ‰©å±•:  é”ç«äº‰ç»Ÿè®¡

struct LockStats {

&nbsp;   int try\_lock\_attempts;

&nbsp;   int try\_lock\_failures;

&nbsp;   double total\_wait\_time;

};



std::map<int, LockStats> fork\_lock\_stats;

```



\### 6.3 æ€§èƒ½å¯¹æ¯”



| åœºæ™¯ | CRITICAL\_SECTION | Mutex å¯¹è±¡ | æ€§èƒ½æå‡ |

|------|-----------------|-----------|---------|

| æ— ç«äº‰ | ~20 ns | ~1000 ns | 50x |

| ä½ç«äº‰ | ~100 ns | ~1000 ns | 10x |

| é«˜ç«äº‰ | ~1000 ns | ~1000 ns | 1x |



---



\## 7. å¸¸è§é—®é¢˜



\### 7.1 ä¸ºä»€ä¹ˆä¸ä½¿ç”¨æ¡ä»¶å˜é‡ï¼Ÿ



\*\*åŸå› \*\*:

\- å½“å‰åœºæ™¯ä½¿ç”¨ `try\_lock()` + è½®è¯¢å·²è¶³å¤Ÿ

\- æ¡ä»¶å˜é‡é€‚åˆç”Ÿäº§è€…-æ¶ˆè´¹è€…çš„é˜»å¡ç­‰å¾…

\- å“²å­¦å®¶ä½¿ç”¨ä¸»åŠ¨è½®è¯¢ï¼Œæ— éœ€é˜»å¡é€šçŸ¥



\*\*æ½œåœ¨ä½¿ç”¨åœºæ™¯\*\*:

```cpp

// å¦‚æœæ”¹ä¸ºé˜»å¡å¼ç­‰å¾…å‰å­å¯ç”¨

class Fork {

&nbsp;   WinMutex mtx;

&nbsp;   CONDITION\_VARIABLE cv;

&nbsp;   bool available;

&nbsp;   

public: 

&nbsp;   void wait\_available() {

&nbsp;       EnterCriticalSection(\&mtx. cs);

&nbsp;       while (!available) {

&nbsp;           SleepConditionVariableCS(\&cv, \&mtx.cs, INFINITE);

&nbsp;       }

&nbsp;       available = false;

&nbsp;       LeaveCriticalSection(\&mtx.cs);

&nbsp;   }

&nbsp;   

&nbsp;   void set\_available() {

&nbsp;       EnterCriticalSection(\&mtx. cs);

&nbsp;       available = true;

&nbsp;       WakeConditionVariable(\&cv);

&nbsp;       LeaveCriticalSection(\&mtx.cs);

&nbsp;   }

};

```



\### 7.2 ä¸ºä»€ä¹ˆä¸ä½¿ç”¨è¯»å†™é”ï¼Ÿ



\*\*åŸå› \*\*:

\- çŠ¶æ€è¯»å†™é¢‘ç‡ç›¸å½“ï¼Œè¯»å†™é”æ”¶ç›Šä¸æ˜æ˜¾

\- `CRITICAL\_SECTION` å®ç°æ›´ç®€å•



\*\*é€‚åˆè¯»å†™é”çš„åœºæ™¯\*\*:

\- è¯»æ“ä½œ >> å†™æ“ä½œï¼ˆå¦‚é…ç½®è¯»å–ï¼‰

\- ä¸´ç•ŒåŒºè¾ƒé•¿ï¼ˆé”æŒæœ‰æ—¶é—´ > 1msï¼‰



---



\## 8. æ€»ç»“



\### 8.1 åŒæ­¥æœºåˆ¶æ±‡æ€»



| æœºåˆ¶ | Windows API | ä½¿ç”¨ä½ç½® | ä½œç”¨ |

|------|------------|---------|------|

| ä¸´ç•ŒåŒº | `CRITICAL\_SECTION` | Fork, Simulation | äº’æ–¥è®¿é—® |

| ä¿¡å·é‡ | `CreateSemaphoreW` | ï¼ˆé¢„ç•™æœªç”¨ï¼‰ | èµ„æºè®¡æ•° |

| çº¿ç¨‹ | `\_beginthreadex` | Simulation | å¹¶å‘æ‰§è¡Œ |

| åŸå­æ“ä½œ | `volatile` | running æ ‡å¿— | æ— é”é€šä¿¡ |



\### 8.2 è®¾è®¡äº®ç‚¹



\- âœ… å®Œå…¨åŸºäº Windows åŸç”Ÿ API

\- âœ… RAII ä¿è¯å¼‚å¸¸å®‰å…¨

\- âœ… éé˜»å¡ + å›é€€ç­–ç•¥é¿å…æ­»é”

\- âœ… Banker's Algorithm é¢„é˜²æ­»é”

\- âœ… åé¥¥é¥¿ä¼˜å…ˆçº§è°ƒåº¦



\### 8.3 æ”¹è¿›æ–¹å‘



\- âš ï¸ æ·»åŠ æ¡ä»¶å˜é‡ä¼˜åŒ–ç­‰å¾…

\- âš ï¸ ä½¿ç”¨è¯»å†™é”ä¼˜åŒ–çŠ¶æ€æŸ¥è¯¢

\- âš ï¸ å®ç°æ— é”é˜Ÿåˆ—å‡å°‘å¼€é”€



---



\*\*æ–‡æ¡£ç‰ˆæœ¬å†å²\*\*: 

\- v1.0 (2025-12-26): åˆå§‹ç‰ˆæœ¬

