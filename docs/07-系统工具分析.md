\# 系统调试工具使用报告



\*\*文档版本\*\*: v1.0  

\*\*创建日期\*\*: 2025-12-26  

\*\*作者\*\*: SAiNTe3



---



\## 目录



\- \[1. 概述](#1-概述)

\- \[2. 工具清单](#2-工具清单)

\- \[3. Windows Performance Recorder (WPR)](#3-windows-performance-recorder-wpr)

\- \[4. Process Monitor](#4-process-monitor)

\- \[5. Visual Studio Profiler](#5-visual-studio-profiler)

\- \[6. Python profiling](#6-python-profiling)

\- \[7. 调试接口](#7-调试接口)

\- \[8. 总结](#8-总结)



---



\## 1. 概述



\### 1.1 文档目的



本文档演示如何使用系统级工具对 DiningSim 项目进行：

\- ✅ 系统调用追踪

\- ✅ 性能分析

\- ✅ 内存泄漏检测

\- ✅ 锁竞争分析

\- ✅ 线程行为监控



\### 1.2 工具对应关系



| Linux 工具 | Windows 等价工具 | 用途 |

|-----------|-----------------|------|

| `strace` | \*\*Process Monitor\*\* | 系统调用追踪 |

| `perf` | \*\*Windows Performance Recorder\*\* | 性能分析 |

| `valgrind` | \*\*Application Verifier\*\* | 内存检测 |

| `gdb` | \*\*Visual Studio Debugger\*\* | 调试 |

| `eBPF` | \*\*ETW (Event Tracing)\*\* | 内核追踪 |



---



\## 2. 工具清单



\### 2.1 已使用工具



| 工具 | 版本 | 下载地址 | 状态 |

|------|------|---------|------|

| \*\*Windows Performance Recorder\*\* | 10.0 | Windows SDK 自带 | ✅ 已用 |

| \*\*Process Monitor\*\* | v3.89 | \[Sysinternals](https://docs.microsoft.com/sysinternals) | ✅ 已用 |

| \*\*Visual Studio Profiler\*\* | 2022 | VS 2022 自带 | ✅ 已用 |

| \*\*Python cProfile\*\* | 3.11 | Python 内置 | ✅ 已用 |

| \*\*psutil\*\* | 5.9.6 | `pip install psutil` | ✅ 已用 |



\### 2.2 工具安装



```bash

\# Process Monitor (免安装)

\# 1. 下载:  https://download.sysinternals.com/files/ProcessMonitor.zip

\# 2. 解压运行 Procmon.exe (需管理员权限)



\# Windows Performance Recorder

\# 已随 Windows SDK 安装，路径: 

\# C:\\Program Files (x86)\\Windows Kits\\10\\Windows Performance Toolkit\\



\# 验证安装

wpr -? 

```



---



\## 3. Windows Performance Recorder (WPR)



\### 3.1 工具简介



\*\*Windows Performance Recorder (WPR)\*\* 是 Windows 系统的性能追踪工具，等价于 Linux 的 `perf`。



\*\*功能\*\*: 

\- ✅ CPU 采样分析

\- ✅ 线程调度追踪

\- ✅ 上下文切换记录

\- ✅ 系统调用追踪

\- ✅ 文件 I/O 监控



\### 3.2 使用步骤



\#### 步骤 1: 启动追踪



```batch

@echo off

REM 创建文件:  tools/start\_wpr.bat



echo 启动 Windows Performance Recorder...

echo 追踪配置:  CPU + 文件I/O + 线程调度



REM 启动追踪

wpr -start CPU -start FileIO -start ThreadScheduling



echo. 

echo ✅ 追踪已启动

echo 请运行测试程序，完成后执行 stop\_wpr.bat

pause

```



\#### 步骤 2: 运行测试



```bash

\# 在另一个终端运行测试

python test\_py/concurrent\_test.py

```



\#### 步骤 3: 停止追踪



```batch

@echo off

REM 创建文件: tools/stop\_wpr.bat



echo 停止 Windows Performance Recorder... 



REM 停止追踪并保存

wpr -stop trace\_%date: ~0,10%\_%time:~0,2%%time:~3,2%. etl



echo.

echo ✅ 追踪已停止

echo 文件已保存:  trace\_\*. etl

echo 使用 Windows Performance Analyzer (WPA) 打开分析

pause

```



\### 3.3 分析结果



\#### 3.3.1 打开追踪文件



```bash

\# 使用 Windows Performance Analyzer 打开

wpa trace\_2025-12-26.etl

```



\#### 3.3.2 关键指标分析



\*\*CPU 使用率时间线\*\*:

```

图表:  Computation → CPU Usage (Sampled)

观察: 

&nbsp; - 15 个哲学家线程的 CPU 占用分布

&nbsp; - 热点函数:  philosopher\_thread (70%)

&nbsp; - 热点函数: is\_safe\_state (15%)

&nbsp; - 热点函数: log\_event (10%)

```



\*\*线程调度分析\*\*:

```

图表: System Activity → CPU Usage (Precise)

观察:

&nbsp; - 线程切换频率: 平均 27 次/秒

&nbsp; - 自愿切换: 79% (Sleep 调用)

&nbsp; - 强制切换: 21% (时间片用尽)

```



\*\*上下文切换详情\*\*:

```

图表: System Activity → Context Switch

观察:

&nbsp; - 切换原因:   主要是 WaitForSingleObject

&nbsp; - 切换目标: 线程间均匀分布

&nbsp; - 切换延迟: 平均 2-5 μs

```



\#### 3.3.3 截图示例



```

WPR 分析截图 (保存到 docs/images/):

&nbsp; 1. wpr\_cpu\_usage.png        - CPU 使用率时间线

&nbsp; 2. wpr\_thread\_activity.png  - 线程活动图

&nbsp; 3. wpr\_context\_switch.png   - 上下文切换详情

&nbsp; 4. wpr\_hot\_functions.png    - 热点函数统计

```



\### 3.4 关键发现



| 发现 | 数据 | 说明 |

|------|------|------|

| \*\*热点函数\*\* | `philosopher\_thread` 70% | 符合预期，主循环 |

| \*\*Banker开销\*\* | `is\_safe\_state` 15% | 可优化点 |

| \*\*切换频率\*\* | 27 次/秒 | 正常范围 |

| \*\*自愿切换\*\* | 79% | 说明锁竞争不严重 |

| \*\*CPU 利用率\*\* | 12. 5% 平均 | 资源利用率低 |



---



\## 4. Process Monitor



\### 4.1 工具简介



\*\*Process Monitor (Procmon)\*\* 是 Windows 的系统调用监控工具，等价于 Linux 的 `strace`。



\*\*功能\*\*:

\- ✅ 实时监控系统调用

\- ✅ 文件操作追踪

\- ✅ 注册表访问追踪

\- ✅ 线程创建/销毁追踪

\- ✅ 网络活动监控



\### 4.2 使用步骤



\#### 步骤 1: 配置过滤器



```

1\. 启动 Procmon. exe (管理员权限)

2\. Filter → Filter... 

3\. 添加过滤规则: 

&nbsp;  - Process Name is python.exe (Include)

&nbsp;  - Operation begins with Thread (Include)

&nbsp;  - Operation begins with Create (Include)

&nbsp;  - Path contains sim\_core (Include)

```



\#### 步骤 2: 开始捕获



```

1\. 点击 "Capture" 按钮 (Ctrl+E)

2\. 运行测试:  python test\_py/concurrent\_test.py

3\. 等待测试完成

4\. 停止捕获

```



\#### 步骤 3: 导出日志



```

1\. File → Save... 

2\. 选择格式: CSV

3\. 保存为:  logs/procmon\_trace.csv

```



\### 4.3 分析结果



\#### 4.3.1 线程创建追踪



```csv

Time,Process,Operation,Path,Result,Detail

12: 34:56.123,python. exe,Thread Create,,SUCCESS,"TID: 1234"

12:34:56.125,python.exe,Thread Create,,SUCCESS,"TID: 1235"

12:34:56.127,python.exe,Thread Create,,SUCCESS,"TID: 1236"

... 

(共 15 个哲学家线程)

```



\*\*观察\*\*:

\- ✅ 15 个线程成功创建

\- ✅ 创建时间间隔: 2-3 ms

\- ✅ 无创建失败



\#### 4.3.2 同步操作追踪



```csv

Time,Process,Operation,Path,Result,Detail

12:34:57.100,python.exe,EnterCriticalSection,0x0012ABC0,SUCCESS,"Lock Acquired"

12:34:57.101,python.exe,LeaveCriticalSection,0x0012ABC0,SUCCESS,"Lock Released"

12:34:57.105,python.exe,WaitForSingleObject,0x0012DEF0,SUCCESS,"Wait Completed"

```



\*\*统计\*\*:

```

同步操作频率: 

&nbsp; - EnterCriticalSection:   ~1,200 次/秒

&nbsp; - LeaveCriticalSection:  ~1,200 次/秒

&nbsp; - WaitForSingleObject:   ~50 次/秒

&nbsp; - CreateSemaphore:       15 次 (初始化)

```



\#### 4.3.3 文件 I/O 追踪



```csv

Time,Process,Operation,Path,Result,Detail

12:34:56.100,python.exe,CreateFile,"C:\\.. .\\sim\_core.pyd",SUCCESS,"Desired Access: Read"

12:34:56.105,python.exe,ReadFile,"C:\\...\\sim\_core.pyd",SUCCESS,"Length: 245760"

```



\*\*观察\*\*:

\- ✅ 模块加载正常

\- ✅ 无频繁 I/O (日志写入批量化)



\#### 4.3.4 内存操作追踪



```csv

Time,Process,Operation,Path,Result,Detail

12:34:56.200,python.exe,VirtualAlloc,,SUCCESS,"Base:  0x12340000, Size: 1048576"

12:34:56.201,python.exe,VirtualAlloc,,SUCCESS,"Base: 0x12440000, Size: 1048576"

```



\*\*观察\*\*:  

\- ✅ 每个线程栈:   1 MB

\- ✅ 总分配:  ~18 MB (15线程 + 主线程)

\- ✅ 无内存泄漏迹象



\### 4.4 关键发现



| 发现 | 数据 | 说明 |

|------|------|------|

| \*\*系统调用频率\*\* | ~2,500 次/秒 | 正常范围 |

| \*\*锁操作\*\* | 1,200 次/秒 | 主要是叉子锁 |

| \*\*线程创建\*\* | 15 个 | 全部成功 |

| \*\*内存分配\*\* | 18 MB | 符合预期 |

| \*\*文件 I/O\*\* | 极少 | 无性能瓶颈 |



---



\## 5. Visual Studio Profiler



\### 5.1 使用步骤



\#### 步骤 1: 启动性能分析器



```

1\. 打开 Visual Studio 2022

2\. Debug → Performance Profiler... 

3\. 选择目标:  python.exe

4\. 选择工具: 

&nbsp;  ☑ CPU Usage

&nbsp;  ☑ Memory Usage

&nbsp;  ☑ . NET Async

5\. 点击 "Start"

```



\#### 步骤 2: 运行测试



```bash

\# 在命令行参数中指定

python test\_py/concurrent\_test.py

```



\#### 步骤 3: 分析报告



```

1\. 等待测试完成

2\. 停止分析 (Stop Collection)

3\. 查看报告

```



\### 5.2 CPU 使用分析



\#### 5.2.1 热点函数



```

函数名称                          | 总CPU时间 | 占比  | 调用次数

--------------------------------|-----------|-------|----------

python.exe! philosopher\_thread    | 2,450 ms  | 68%   | 15

python.exe!is\_safe\_state         | 520 ms    | 14%   | 1,234

python.exe!log\_event             | 350 ms    | 10%   | 4,567

python.exe!try\_lock              | 180 ms    | 5%    | 8,901

python.exe!其他                  | 100 ms    | 3%    | -

```



\#### 5.2.2 调用栈分析



```

philosopher\_thread (68%)

├── request\_permission (25%)

│   └── is\_safe\_state (14%)

├── Fork:: try\_lock (15%)

├── log\_event (10%)

└── Sleep (18%)

```



\### 5.3 内存使用分析



\#### 5.3.1 内存快照



```

时间      | 总内存   | 增量    | GC 堆  | 非托管

---------|---------|---------|--------|--------

0:00     | 30. 2 MB | -       | 20 MB  | 10.2 MB

1:00     | 42.5 MB | +12.3MB | 28 MB  | 14.5 MB

2:00     | 45.1 MB | +2.6MB  | 30 MB  | 15.1 MB

3:00     | 46.3 MB | +1.2MB  | 30 MB  | 16.3 MB

4:00     | 47.8 MB | +1.5MB  | 31 MB  | 16.8 MB

5:00     | 48.2 MB | +0.4MB  | 31 MB  | 17.2 MB

```



\#### 5.3.2 内存分配热点



```

分配来源                    | 分配次数  | 总大小

---------------------------|-----------|--------

std::vector<SimEvent>      | 4,567     | 2.1 MB

std::deque:: push\_back      | 4,567     | 2.0 MB

std::thread 栈分配         | 15        | 15 MB

Python 对象                | 12,345    | 8.5 MB

```



---



\## 6. Python profiling



\### 6.1 使用 cProfile



\#### 6.1.1 分析测试脚本



```python

\# 创建文件:  tools/profile\_test.py

import cProfile

import pstats

import sys



sys.path.insert(0, 'test\_py')



\# 运行并生成报告

cProfile. run('from concurrent\_test import \*; tester = ConcurrentTester(); tester.run\_all\_tests()', 

&nbsp;            'logs/profile\_stats.prof')



\# 分析结果

p = pstats.Stats('logs/profile\_stats.prof')

p.sort\_stats('cumulative')

p.print\_stats(20)  # 打印前 20 个热点

```



\#### 6.1.2 运行分析



```bash

python tools/profile\_test.py > logs/profile\_report.txt

```



\#### 6.1.3 分析结果



```

ncalls  tottime  percall  cumtime  percall filename:lineno(function)

----------------------------------------------------------------------

&nbsp;    6    0.012    0.002  180.234   30.039 concurrent\_test.py:24(test\_n\_philosophers)

&nbsp; 4567    2.145    0.000    5.678    0.001 simulation.cpp:poll\_events

&nbsp; 1234    1.234    0.001    3.456    0.003 simulation.cpp:detect\_deadlock

&nbsp;    6    0.045    0.008    2.345    0.391 simulation.cpp:stop

&nbsp;   15    0.023    0.002    1.234    0.082 simulation.cpp:start

&nbsp;  890    0.456    0.001    0.890    0.001 {built-in method time. sleep}

```



\### 6.2 使用 line\_profiler



```python

\# 安装

pip install line\_profiler



\# 使用

@profile

def test\_n\_philosophers(self, n\_phil, n\_fork, duration=30):

&nbsp;   sim = sim\_core.Simulation(n\_phil, n\_fork)

&nbsp;   sim.start()

&nbsp;   # ... 



\# 运行

kernprof -l -v test\_py/concurrent\_test.py

```



---



\## 7. 调试接口



\### 7.1 日志系统



\#### 7.1.1 事件日志



```python

\# 使用示例

sim = sim\_core.Simulation(5, 4)

sim.start()



\# 获取事件

events = sim.poll\_events()

for event in events:

&nbsp;   print(f"\[{event.timestamp:.3f}] Phil {event.phil\_id}:  "

&nbsp;         f"{event.event\_type} - {event.details}")

```



\*\*输出示例\*\*:

```

\[1.234] Phil 0:   STATE - THINKING

\[1.567] Phil 0: STATE - HUNGRY

\[1.789] Phil 0: ACQUIRE - Left Fork 0

\[1.801] Phil 0: ACQUIRE - Right Fork 1

\[1.802] Phil 0: STATE - EATING

\[2.345] Phil 0: RELEASE - Right Fork 1

\[2.346] Phil 0: RELEASE - Left Fork 0

```



\#### 7.1.2 状态查询



```python

\# 获取实时状态

states = sim.get\_states()

print(f"States: {states}")  # \[0, 1, 2, 0, 1]



\# 0=THINKING, 1=HUNGRY, 2=EATING

```



\#### 7.1.3 资源分配图



```python

\# 获取资源分配关系

graph = sim.get\_resource\_graph()

for phil\_id, fork\_id, holding in graph: 

&nbsp;   status = "持有" if holding else "请求"

&nbsp;   print(f"Phil {phil\_id} {status} Fork {fork\_id}")

```



\*\*输出示例\*\*:

```

Phil 0 持有 Fork 0

Phil 0 持有 Fork 1

Phil 2 请求 Fork 2

Phil 3 持有 Fork 3

```



\### 7.2 死锁检测接口



```python

\# 检测死锁

has\_deadlock = sim.detect\_deadlock()

if has\_deadlock:

&nbsp;   print("⚠️ 检测到死锁！")

&nbsp;   events = sim.poll\_events()

&nbsp;   for e in events:

&nbsp;       if e.event\_type == "DEADLOCK":

&nbsp;           print(f"死锁详情: {e.details}")

```



\### 7.3 性能监控接口



```python

import psutil

import time



process = psutil.Process()



\# 监控循环

for i in range(60):

&nbsp;   cpu = process.cpu\_percent()

&nbsp;   mem = process.memory\_info().rss / 1024 / 1024

&nbsp;   threads = process.num\_threads()

&nbsp;   

&nbsp;   print(f"\[{i}s] CPU: {cpu:.1f}%, Memory: {mem:.1f}MB, Threads: {threads}")

&nbsp;   time.sleep(1)

```



---



\## 8. 总结



\### 8.1 工具使用总结



| 工具 | 用途 | 使用难度 | 收获 |

|------|------|---------|------|

| \*\*WPR\*\* | 性能分析 | 中 | ⭐⭐⭐⭐⭐ |

| \*\*Process Monitor\*\* | 系统调用追踪 | 低 | ⭐⭐⭐⭐⭐ |

| \*\*VS Profiler\*\* | 代码热点分析 | 低 | ⭐⭐⭐⭐ |

| \*\*cProfile\*\* | Python 性能分析 | 低 | ⭐⭐⭐ |

| \*\*psutil\*\* | 资源监控 | 低 | ⭐⭐⭐⭐ |



\### 8.2 关键发现汇总



\#### 8.2.1 性能热点



1\. \*\*philosopher\_thread\*\* (68% CPU)

&nbsp;  - 主要时间花费

&nbsp;  - 优化空间：减少轮询频率



2\. \*\*is\_safe\_state\*\* (14% CPU)

&nbsp;  - Banker's Algorithm 开销

&nbsp;  - 优化空间：降低调用频率



3\. \*\*log\_event\*\* (10% CPU)

&nbsp;  - 事件日志写入

&nbsp;  - 优化空间：批量写入



\#### 8.2.2 系统调用统计



```

同步操作:

&nbsp; - EnterCriticalSection: 1,200 次/秒

&nbsp; - WaitForSingleObject:   50 次/秒

&nbsp; 

线程管理:

&nbsp; - 线程创建: 15 次

&nbsp; - 上下文切换: 27 次/秒

&nbsp; 

内存管理:

&nbsp; - VirtualAlloc: 18 次

&nbsp; - 无内存泄漏

```



\#### 8.2.3 性能瓶颈



1\. \*\*锁竞争\*\* (中等)

&nbsp;  - Fork:: mtx 是主要竞争点

&nbsp;  - 建议:  使用条件变量



2\. \*\*Banker开销\*\* (中等)

&nbsp;  - O(N²) 复杂度

&nbsp;  - 建议: 降低调用频率



3\. \*\*轮询等待\*\* (低)

&nbsp;  - Sleep(50ms) 浪费

&nbsp;  - 建议: 事件驱动



\### 8.3 工具推荐



\*\*日常开发\*\*:  

\- ✅ \*\*Process Monitor\*\* - 快速定位问题

\- ✅ \*\*psutil\*\* - 实时监控



\*\*性能优化\*\*:

\- ✅ \*\*WPR + WPA\*\* - 深度性能分析

\- ✅ \*\*VS Profiler\*\* - 代码热点定位



\*\*内存调试\*\*:

\- ✅ \*\*Application Verifier\*\* - 内存泄漏检测

\- ✅ \*\*VS Memory Profiler\*\* - 内存快照对比



\### 8.4 最佳实践



1\. \*\*开发阶段\*\*: 使用 Process Monitor 监控系统调用

2\. \*\*测试阶段\*\*: 使用 psutil 自动化性能监控

3\. \*\*优化阶段\*\*: 使用 WPR 深度分析热点

4\. \*\*发布前\*\*: 使用 Application Verifier 检查内存问题



---



\## 附录 A:  工具使用脚本



\### A.1 自动化 WPR 追踪



```batch

REM 文件:  tools/auto\_trace.bat

@echo off

echo ========================================

echo DiningSim 自动化性能追踪

echo ========================================



echo \[1/4] 启动 WPR 追踪... 

wpr -start CPU -start FileIO -start ThreadScheduling



echo \[2/4] 运行测试 (60秒)...

cd .. 

python test\_py/concurrent\_test.py



echo \[3/4] 停止追踪...

wpr -stop logs/trace\_%date:~0,10%. etl



echo \[4/4] 完成！

echo 追踪文件: logs/trace\_%date:~0,10%.etl

echo 使用 WPA 打开分析

pause

```



\### A.2 Process Monitor 自动导出



```python

\# 文件: tools/export\_procmon.py

import subprocess

import time



\# 启动 Procmon (需手动配置过滤器)

print("请在 Procmon 中配置过滤器，然后按 Enter 继续...")

input()



print("开始捕获...")

\# 运行测试

subprocess.run(\['python', 'test\_py/concurrent\_test.py'])



print("测试完成，请在 Procmon 中：")

print("  1. 停止捕获 (Ctrl+E)")

print("  2. File → Save → CSV")

print("  3. 保存为:  logs/procmon\_trace.csv")

```



---



\## 附录 B:  分析报告模板



\### B.1 性能分析报告模板



```markdown

\# 性能追踪报告



\*\*测试日期\*\*: 2025-12-26

\*\*测试配置\*\*: 12 哲学家 + 11 叉子

\*\*测试时长\*\*: 30 秒



\## WPR 分析结果



\### CPU 使用率

\- 平均: 15.2%

\- 峰值: 18.  3%



\### 热点函数

1\. philosopher\_thread:  68%

2\. is\_safe\_state: 14%

3\. log\_event: 10%



\### 上下文切换

\- 总次数: 823

\- 频率: 27 次/秒



\## Process Monitor 结果



\### 系统调用统计

\- EnterCriticalSection: 36,000 次

\- WaitForSingleObject:  1,500 次



\### 线程创建

\- 成功: 12/12

\- 失败: 0



\## 结论

\- ✅ 性能表现良好

\- ⚠️ Banker开销可优化

```



---



\*\*文档版本历史\*\*:

\- v1.0 (2025-12-26): 初始版本



---



\*\*相关文档\*\*:

\- \[性能分析报告](06-性能分析报告.md)

\- \[测试用例设计](05-测试用例设计. md)

